<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shooter-Game: Pathfinding.PathUtilities Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shooter-Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pathfinding_1_1_path_utilities.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_pathfinding_1_1_path_utilities-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pathfinding.PathUtilities Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains useful functions for working with paths and nodes.  
 <a href="class_pathfinding_1_1_path_utilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4725e115e59fa8e9f2bd26bd40a6349d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a4725e115e59fa8e9f2bd26bd40a6349d">IsPathPossible</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> node1, <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> node2)</td></tr>
<tr class="memdesc:a4725e115e59fa8e9f2bd26bd40a6349d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there is a walkable path from node1 to node2.  <a href="class_pathfinding_1_1_path_utilities.html#a4725e115e59fa8e9f2bd26bd40a6349d">More...</a><br /></td></tr>
<tr class="separator:a4725e115e59fa8e9f2bd26bd40a6349d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c65409c2f47489c426cf9b9614e78a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a9c65409c2f47489c426cf9b9614e78a0">IsPathPossible</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes)</td></tr>
<tr class="memdesc:a9c65409c2f47489c426cf9b9614e78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there are walkable paths between all nodes.  <a href="class_pathfinding_1_1_path_utilities.html#a9c65409c2f47489c426cf9b9614e78a0">More...</a><br /></td></tr>
<tr class="separator:a9c65409c2f47489c426cf9b9614e78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#aca9c8e2befb7f0e4fe6dcf399a22c66c">IsPathPossible</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes, int tagMask)</td></tr>
<tr class="memdesc:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there are walkable paths between all nodes.  <a href="class_pathfinding_1_1_path_utilities.html#aca9c8e2befb7f0e4fe6dcf399a22c66c">More...</a><br /></td></tr>
<tr class="separator:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7a5d437efa7ca8a068b20ed68042fd"><td class="memItemLeft" align="right" valign="top">static List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a8d7a5d437efa7ca8a068b20ed68042fd">GetReachableNodes</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> seed, int tagMask=-1, System.Func&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>, bool &gt; filter=null)</td></tr>
<tr class="memdesc:a8d7a5d437efa7ca8a068b20ed68042fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all nodes reachable from the seed node.  <a href="class_pathfinding_1_1_path_utilities.html#a8d7a5d437efa7ca8a068b20ed68042fd">More...</a><br /></td></tr>
<tr class="separator:a8d7a5d437efa7ca8a068b20ed68042fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199d4069cfeb46704d006ed7ede45e08"><td class="memItemLeft" align="right" valign="top">static List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a199d4069cfeb46704d006ed7ede45e08">BFS</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> seed, int depth, int tagMask=-1, System.Func&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>, bool &gt; filter=null)</td></tr>
<tr class="memdesc:a199d4069cfeb46704d006ed7ede45e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all nodes up to a given node-distance from the seed node.  <a href="class_pathfinding_1_1_path_utilities.html#a199d4069cfeb46704d006ed7ede45e08">More...</a><br /></td></tr>
<tr class="separator:a199d4069cfeb46704d006ed7ede45e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="memItemLeft" align="right" valign="top">static List&lt; Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a8cfaf4b4a4759ede29bf06a4d2775263">GetSpiralPoints</a> (int count, float clearance)</td></tr>
<tr class="memdesc:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns points in a spiral centered around the origin with a minimum clearance from other points.  <a href="class_pathfinding_1_1_path_utilities.html#a8cfaf4b4a4759ede29bf06a4d2775263">More...</a><br /></td></tr>
<tr class="separator:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dbca938d4f6cf727654e514d690826"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#ae6dbca938d4f6cf727654e514d690826">GetPointsAroundPointWorld</a> (Vector3 p, <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a> g, List&lt; Vector3 &gt; previousPoints, float radius, float clearanceRadius)</td></tr>
<tr class="memdesc:ae6dbca938d4f6cf727654e514d690826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will calculate a number of points around p which are on the graph and are separated by clearance from each other.  <a href="class_pathfinding_1_1_path_utilities.html#ae6dbca938d4f6cf727654e514d690826">More...</a><br /></td></tr>
<tr class="separator:ae6dbca938d4f6cf727654e514d690826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d526b4584d6d29587e38e4141d5e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a810d526b4584d6d29587e38e4141d5e6">GetPointsAroundPoint</a> (Vector3 center, <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a> g, List&lt; Vector3 &gt; previousPoints, float radius, float clearanceRadius)</td></tr>
<tr class="memdesc:a810d526b4584d6d29587e38e4141d5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will calculate a number of points around center which are on the graph and are separated by clearance from each other.  <a href="class_pathfinding_1_1_path_utilities.html#a810d526b4584d6d29587e38e4141d5e6">More...</a><br /></td></tr>
<tr class="separator:a810d526b4584d6d29587e38e4141d5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="memItemLeft" align="right" valign="top">static List&lt; Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#ad9e63781b73c5eb340c8b6e9fe7927dc">GetPointsOnNodes</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes, int count, float clearanceRadius=0)</td></tr>
<tr class="memdesc:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns randomly selected points on the specified nodes with each point being separated by clearanceRadius from each other.  <a href="class_pathfinding_1_1_path_utilities.html#ad9e63781b73c5eb340c8b6e9fe7927dc">More...</a><br /></td></tr>
<tr class="separator:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains useful functions for working with paths and nodes. </p>
<p>This class works a lot with the <a class="el" href="class_pathfinding_1_1_graph_node.html" title="Base class for all nodes">Pathfinding.GraphNode</a> class, a useful function to get nodes is <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint.">AstarPath.GetNearest</a>. See: <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint.">AstarPath.GetNearest</a> See: <a class="el" href="class_pathfinding_1_1_graph_update_utilities.html" title="Contains useful functions for updating graphs.">Pathfinding.GraphUpdateUtilities</a> See: <a class="el" href="class_pathfinding_1_1_graph_utilities.html" title="Contains utility methods for getting useful information out of graph.">Pathfinding.GraphUtilities</a></p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a199d4069cfeb46704d006ed7ede45e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199d4069cfeb46704d006ed7ede45e08">&#9670;&nbsp;</a></span>BFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&gt; Pathfinding.PathUtilities.BFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">System.Func&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>, bool &gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all nodes up to a given node-distance from the seed node. </p>
<p>This function performs a BFS (<a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>) or flood fill of the graph and returns all nodes within a specified node distance which can be reached from the seed node. In almost all cases when depth is large enough this will be identical to returning all nodes which have the same area as the seed node. In the editor areas are displayed as different colors of the nodes. The only case where it will not be so is when there is a one way path from some part of the area to the seed node but no path from the seed node to that part of the graph.</p>
<p>The returned list is sorted by node distance from the seed node i.e distance is measured in the number of nodes the shortest path from seed to that node would pass through. Note that the distance measurement does not take heuristics, penalties or tag penalties.</p>
<p>Depending on the number of nodes, this function can take quite some time to calculate so don't use it too often or it might affect the framerate of your game.</p>
<p>Returns: A List&lt;GraphNode&gt; containing all nodes reachable up to a specified node distance from the seed node. For better memory management the returned list should be pooled, see <a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool.">Pathfinding.Util.ListPool</a></p>
<p>Warning: This method is not thread safe. Only use it from the Unity thread (i.e normal game code).</p>
<p>The video below shows the BFS result with varying values of depth. Points are sampled on the nodes using <a class="el" href="class_pathfinding_1_1_path_utilities.html#ad9e63781b73c5eb340c8b6e9fe7927dc" title="Returns randomly selected points on the specified nodes with each point being separated by clearanceR...">GetPointsOnNodes</a>. [Open online documentation to see videos]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The node to start the search from.</td></tr>
    <tr><td class="paramname">depth</td><td>The maximum node-distance from the seed node.</td></tr>
    <tr><td class="paramname">tagMask</td><td>Optional mask for tags. This is a bitmask.</td></tr>
    <tr><td class="paramname">filter</td><td>Optional filter for which nodes to search. You can combine this with depth = int.MaxValue and tagMask = -1 to make the filter determine everything. Only walkable nodes are searched regardless of the filter. If the filter function returns false the node will be treated as unwalkable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a810d526b4584d6d29587e38e4141d5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d526b4584d6d29587e38e4141d5e6">&#9670;&nbsp;</a></span>GetPointsAroundPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Pathfinding.PathUtilities.GetPointsAroundPoint </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; Vector3 &gt;&#160;</td>
          <td class="paramname"><em>previousPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will calculate a number of points around center which are on the graph and are separated by clearance from each other. </p>
<p>The maximum distance from center to any point will be radius. Points will first be tried to be laid out as previousPoints and if that fails, random points will be selected. This is great if you want to pick a number of target points for group movement. If you pass all current agent points from e.g the group's average position this method will return target points so that the units move very little within the group, this is often aesthetically pleasing and reduces jitter if using some kind of local avoidance.</p>
<p>TODO: Write unit tests</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The point to generate points around</td></tr>
    <tr><td class="paramname">g</td><td>The graph to use for linecasting. If you are only using one graph, you can get this by AstarPath.active.graphs[0] as <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html" title="Graph which supports the Linecast method">IRaycastableGraph</a>. Note that not all graphs are raycastable, recast, navmesh and grid graphs are raycastable. On recast and navmesh it works the best.</td></tr>
    <tr><td class="paramname">previousPoints</td><td>The points to use for reference. Note that these should not be in world space. They are treated as relative to center. The new points will overwrite the existing points in the list. The result will be in world space, not relative to center.</td></tr>
    <tr><td class="paramname">radius</td><td>The final points will be at most this distance from center.</td></tr>
    <tr><td class="paramname">clearanceRadius</td><td>The points will if possible be at least this distance from each other.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6dbca938d4f6cf727654e514d690826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dbca938d4f6cf727654e514d690826">&#9670;&nbsp;</a></span>GetPointsAroundPointWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Pathfinding.PathUtilities.GetPointsAroundPointWorld </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; Vector3 &gt;&#160;</td>
          <td class="paramname"><em>previousPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will calculate a number of points around p which are on the graph and are separated by clearance from each other. </p>
<p>This is like GetPointsAroundPoint except that previousPoints are treated as being in world space. The average of the points will be found and then that will be treated as the group center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to generate points around</td></tr>
    <tr><td class="paramname">g</td><td>The graph to use for linecasting. If you are only using one graph, you can get this by AstarPath.active.graphs[0] as <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html" title="Graph which supports the Linecast method">IRaycastableGraph</a>. Note that not all graphs are raycastable, recast, navmesh and grid graphs are raycastable. On recast and navmesh it works the best.</td></tr>
    <tr><td class="paramname">previousPoints</td><td>The points to use for reference. Note that these are in world space. The new points will overwrite the existing points in the list. The result will be in world space.</td></tr>
    <tr><td class="paramname">radius</td><td>The final points will be at most this distance from p.</td></tr>
    <tr><td class="paramname">clearanceRadius</td><td>The points will if possible be at least this distance from each other.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9e63781b73c5eb340c8b6e9fe7927dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e63781b73c5eb340c8b6e9fe7927dc">&#9670;&nbsp;</a></span>GetPointsOnNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;Vector3&gt; Pathfinding.PathUtilities.GetPointsOnNodes </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns randomly selected points on the specified nodes with each point being separated by clearanceRadius from each other. </p>
<p>Selecting points ON the nodes only works for <a class="el" href="class_pathfinding_1_1_triangle_mesh_node.html" title="Node represented by a triangle">TriangleMeshNode</a> (used by Recast Graph and Navmesh Graph) and <a class="el" href="class_pathfinding_1_1_grid_node.html" title="Node used for the GridGraph">GridNode</a> (used by <a class="el" href="class_pathfinding_1_1_grid_graph.html" title="Generates a grid of nodes.">GridGraph</a>). For other node types, only the positions of the nodes will be used.</p>
<p>clearanceRadius will be reduced if no valid points can be found.</p>
<p>Note: This method assumes that the nodes in the list have the same type for some special cases. More specifically if the first node is not a <a class="el" href="class_pathfinding_1_1_triangle_mesh_node.html" title="Node represented by a triangle">TriangleMeshNode</a> or a <a class="el" href="class_pathfinding_1_1_grid_node.html" title="Node used for the GridGraph">GridNode</a>, it will use a fast path which assumes that all nodes in the list have the same surface area (which usually is a surface area of zero and the nodes are all PointNodes).</p>

</div>
</div>
<a id="a8d7a5d437efa7ca8a068b20ed68042fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7a5d437efa7ca8a068b20ed68042fd">&#9670;&nbsp;</a></span>GetReachableNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&gt; Pathfinding.PathUtilities.GetReachableNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">System.Func&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>, bool &gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all nodes reachable from the seed node. </p>
<p>This function performs a DFS (depth-first-search) or flood fill of the graph and returns all nodes which can be reached from the seed node. In almost all cases this will be identical to returning all nodes which have the same area as the seed node. In the editor areas are displayed as different colors of the nodes. The only case where it will not be so is when there is a one way path from some part of the area to the seed node but no path from the seed node to that part of the graph.</p>
<p>The returned list is not sorted in any particular way.</p>
<p>Depending on the number of reachable nodes, this function can take quite some time to calculate so don't use it too often or it might affect the framerate of your game.</p>
<p>See: bitmasks (view in online documentation for working links).</p>
<p>Returns: A List&lt;Node&gt; containing all nodes reachable from the seed node. For better memory management the returned list should be pooled, see <a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool.">Pathfinding.Util.ListPool</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The node to start the search from.</td></tr>
    <tr><td class="paramname">tagMask</td><td>Optional mask for tags. This is a bitmask.</td></tr>
    <tr><td class="paramname">filter</td><td>Optional filter for which nodes to search. You can combine this with tagMask = -1 to make the filter determine everything. Only walkable nodes are searched regardless of the filter. If the filter function returns false the node will be treated as unwalkable.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO: Pool</p>

</div>
</div>
<a id="a8cfaf4b4a4759ede29bf06a4d2775263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfaf4b4a4759ede29bf06a4d2775263">&#9670;&nbsp;</a></span>GetSpiralPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;Vector3&gt; Pathfinding.PathUtilities.GetSpiralPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns points in a spiral centered around the origin with a minimum clearance from other points. </p>
<p>The points are laid out on the involute of a circle See: <a href="http://en.wikipedia.org/wiki/Involute">http://en.wikipedia.org/wiki/Involute</a> Which has some nice properties. All points are separated by clearance world units. This method is O(n), yes if you read the code you will see a binary search, but that binary search has an upper bound on the number of steps, so it does not yield a log factor.</p>
<p>Note: Consider recycling the list after usage to reduce allocations. See: <a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool.">Pathfinding.Util.ListPool</a></p>

</div>
</div>
<a id="a4725e115e59fa8e9f2bd26bd40a6349d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4725e115e59fa8e9f2bd26bd40a6349d">&#9670;&nbsp;</a></span>IsPathPossible() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there is a walkable path from node1 to node2. </p>
<p>This method is extremely fast because it only uses precalculated information.</p>
<p><code> <a class="el" href="class_pathfinding_1_1_graph_node.html" title="Base class for all nodes">GraphNode</a> node1 = AstarPath.active.GetNearest(point1, <a class="el" href="class_pathfinding_1_1_n_n_constraint.html#a291331904058c3a43f45d5660ca3c011" title="The default NNConstraint.">NNConstraint.Default</a>).node; <a class="el" href="class_pathfinding_1_1_graph_node.html" title="Base class for all nodes">GraphNode</a> node2 = AstarPath.active.GetNearest(point2, <a class="el" href="class_pathfinding_1_1_n_n_constraint.html#a291331904058c3a43f45d5660ca3c011" title="The default NNConstraint.">NNConstraint.Default</a>).node;</code></p>
<p><code>if (PathUtilities.IsPathPossible(node1, node2)) { // Yay, there is a path between those two nodes } </code></p>
<p>See: graph-updates (view in online documentation for working links) See: <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint.">AstarPath.GetNearest</a></p>

</div>
</div>
<a id="a9c65409c2f47489c426cf9b9614e78a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c65409c2f47489c426cf9b9614e78a0">&#9670;&nbsp;</a></span>IsPathPossible() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there are walkable paths between all nodes. </p>
<p>See: graph-updates (view in online documentation for working links)</p>
<p>Returns true for empty lists.</p>
<p>See: <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint.">AstarPath.GetNearest</a></p>

</div>
</div>
<a id="aca9c8e2befb7f0e4fe6dcf399a22c66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c8e2befb7f0e4fe6dcf399a22c66c">&#9670;&nbsp;</a></span>IsPathPossible() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there are walkable paths between all nodes. </p>
<p>See: graph-updates (view in online documentation for working links)</p>
<p>This method will actually only check if the first node can reach all other nodes. However this is equivalent in 99% of the cases since almost always the graph connections are bidirectional. If you are not aware of any cases where you explicitly create unidirectional connections this method can be used without worries.</p>
<p>Returns true for empty lists</p>
<p>Warning: This method is significantly slower than the IsPathPossible method which does not take a tagMask</p>
<p>See: <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint.">AstarPath.GetNearest</a></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Shooter-Game/Shooter-Game/Assets/AstarPathfindingProject/Utilities/<a class="el" href="_path_utilities_8cs.html">PathUtilities.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pathfinding.html">Pathfinding</a></li><li class="navelem"><a class="el" href="class_pathfinding_1_1_path_utilities.html">PathUtilities</a></li>
    <li class="footer">Generated on Mon May 25 2020 18:01:00 for Shooter-Game by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
