<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shooter-Game: Pathfinding.VectorMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shooter-Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pathfinding_1_1_vector_math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_pathfinding_1_1_vector_math-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pathfinding.VectorMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Various vector math utility functions.  
 <a href="class_pathfinding_1_1_vector_math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a03876b8c0a0d21fa8eb9e280e647f3d1"><td class="memItemLeft" align="right" valign="top">static Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a03876b8c0a0d21fa8eb9e280e647f3d1">ComplexMultiply</a> (Vector2 a, Vector2 b)</td></tr>
<tr class="memdesc:a03876b8c0a0d21fa8eb9e280e647f3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number multiplication.  <a href="class_pathfinding_1_1_vector_math.html#a03876b8c0a0d21fa8eb9e280e647f3d1">More...</a><br /></td></tr>
<tr class="separator:a03876b8c0a0d21fa8eb9e280e647f3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54385ca63c8579407785f91976cd9be2"><td class="memItemLeft" align="right" valign="top">static Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a54385ca63c8579407785f91976cd9be2">ComplexMultiplyConjugate</a> (Vector2 a, Vector2 b)</td></tr>
<tr class="memdesc:a54385ca63c8579407785f91976cd9be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number multiplication.  <a href="class_pathfinding_1_1_vector_math.html#a54385ca63c8579407785f91976cd9be2">More...</a><br /></td></tr>
<tr class="separator:a54385ca63c8579407785f91976cd9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116acf72b5591b3f4c82532a8d3cf7d5"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a116acf72b5591b3f4c82532a8d3cf7d5">ClosestPointOnLine</a> (Vector3 lineStart, Vector3 lineEnd, Vector3 point)</td></tr>
<tr class="memdesc:a116acf72b5591b3f4c82532a8d3cf7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest point on the line.  <a href="class_pathfinding_1_1_vector_math.html#a116acf72b5591b3f4c82532a8d3cf7d5">More...</a><br /></td></tr>
<tr class="separator:a116acf72b5591b3f4c82532a8d3cf7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb33e82b3464ee7432eb023a401d2bd"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a8cb33e82b3464ee7432eb023a401d2bd">ClosestPointOnLineFactor</a> (Vector3 lineStart, Vector3 lineEnd, Vector3 point)</td></tr>
<tr class="memdesc:a8cb33e82b3464ee7432eb023a401d2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor along the line which is closest to the point.  <a href="class_pathfinding_1_1_vector_math.html#a8cb33e82b3464ee7432eb023a401d2bd">More...</a><br /></td></tr>
<tr class="separator:a8cb33e82b3464ee7432eb023a401d2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7ff9cc27bda631b034bd7ea3f5362"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a36a7ff9cc27bda631b034bd7ea3f5362">ClosestPointOnLineFactor</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> lineStart, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> lineEnd, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> point)</td></tr>
<tr class="memdesc:a36a7ff9cc27bda631b034bd7ea3f5362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor along the line which is closest to the point.  <a href="class_pathfinding_1_1_vector_math.html#a36a7ff9cc27bda631b034bd7ea3f5362">More...</a><br /></td></tr>
<tr class="separator:a36a7ff9cc27bda631b034bd7ea3f5362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79067e13005b86e7daea6923d769889"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ab79067e13005b86e7daea6923d769889">ClosestPointOnLineFactor</a> (<a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> lineStart, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> lineEnd, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> point)</td></tr>
<tr class="memdesc:ab79067e13005b86e7daea6923d769889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor of the nearest point on the segment.  <a href="class_pathfinding_1_1_vector_math.html#ab79067e13005b86e7daea6923d769889">More...</a><br /></td></tr>
<tr class="separator:ab79067e13005b86e7daea6923d769889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36542f38432fe94ee67f4ffd206a77f1"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a36542f38432fe94ee67f4ffd206a77f1">ClosestPointOnSegment</a> (Vector3 lineStart, Vector3 lineEnd, Vector3 point)</td></tr>
<tr class="memdesc:a36542f38432fe94ee67f4ffd206a77f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest point on the segment.  <a href="class_pathfinding_1_1_vector_math.html#a36542f38432fe94ee67f4ffd206a77f1">More...</a><br /></td></tr>
<tr class="separator:a36542f38432fe94ee67f4ffd206a77f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bcf48907fc3ab7e699f8da4bdb5ff8"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a40bcf48907fc3ab7e699f8da4bdb5ff8">ClosestPointOnSegmentXZ</a> (Vector3 lineStart, Vector3 lineEnd, Vector3 point)</td></tr>
<tr class="memdesc:a40bcf48907fc3ab7e699f8da4bdb5ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest point on the segment in the XZ plane.  <a href="class_pathfinding_1_1_vector_math.html#a40bcf48907fc3ab7e699f8da4bdb5ff8">More...</a><br /></td></tr>
<tr class="separator:a40bcf48907fc3ab7e699f8da4bdb5ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad12e9697b1caf8805bfb8b9994e20"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a25ad12e9697b1caf8805bfb8b9994e20">SqrDistancePointSegmentApproximate</a> (int x, int z, int px, int pz, int qx, int qz)</td></tr>
<tr class="memdesc:a25ad12e9697b1caf8805bfb8b9994e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate shortest squared distance between x,z and the segment p-q.  <a href="class_pathfinding_1_1_vector_math.html#a25ad12e9697b1caf8805bfb8b9994e20">More...</a><br /></td></tr>
<tr class="separator:a25ad12e9697b1caf8805bfb8b9994e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d3201f5992cdfd3a398ef7d8cf8465"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a69d3201f5992cdfd3a398ef7d8cf8465">SqrDistancePointSegmentApproximate</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> p)</td></tr>
<tr class="memdesc:a69d3201f5992cdfd3a398ef7d8cf8465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate shortest squared distance between x,z and the segment p-q.  <a href="class_pathfinding_1_1_vector_math.html#a69d3201f5992cdfd3a398ef7d8cf8465">More...</a><br /></td></tr>
<tr class="separator:a69d3201f5992cdfd3a398ef7d8cf8465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfeac78a0cd2131138f9c2e620983d6"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a8bfeac78a0cd2131138f9c2e620983d6">SqrDistancePointSegment</a> (Vector3 a, Vector3 b, Vector3 p)</td></tr>
<tr class="memdesc:a8bfeac78a0cd2131138f9c2e620983d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between p and the segment a-b.  <a href="class_pathfinding_1_1_vector_math.html#a8bfeac78a0cd2131138f9c2e620983d6">More...</a><br /></td></tr>
<tr class="separator:a8bfeac78a0cd2131138f9c2e620983d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c685f0070362cf3ed9f41260c689c"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ab28c685f0070362cf3ed9f41260c689c">SqrDistanceSegmentSegment</a> (Vector3 s1, Vector3 e1, Vector3 s2, Vector3 e2)</td></tr>
<tr class="memdesc:ab28c685f0070362cf3ed9f41260c689c"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D minimum distance between 2 segments.  <a href="class_pathfinding_1_1_vector_math.html#ab28c685f0070362cf3ed9f41260c689c">More...</a><br /></td></tr>
<tr class="separator:ab28c685f0070362cf3ed9f41260c689c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b2f9d00ffb6f169b50c61c6e08693c"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a73b2f9d00ffb6f169b50c61c6e08693c">SqrDistanceXZ</a> (Vector3 a, Vector3 b)</td></tr>
<tr class="memdesc:a73b2f9d00ffb6f169b50c61c6e08693c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared distance between two points in the XZ plane  <a href="class_pathfinding_1_1_vector_math.html#a73b2f9d00ffb6f169b50c61c6e08693c">More...</a><br /></td></tr>
<tr class="separator:a73b2f9d00ffb6f169b50c61c6e08693c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541625b686e37660142a01dcde15238"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ae541625b686e37660142a01dcde15238">SignedTriangleAreaTimes2XZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> c)</td></tr>
<tr class="memdesc:ae541625b686e37660142a01dcde15238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed area of a triangle in the XZ plane multiplied by 2.  <a href="class_pathfinding_1_1_vector_math.html#ae541625b686e37660142a01dcde15238">More...</a><br /></td></tr>
<tr class="separator:ae541625b686e37660142a01dcde15238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaa3a1776729dc42edb3a3a73e59369"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a4eaa3a1776729dc42edb3a3a73e59369">SignedTriangleAreaTimes2XZ</a> (Vector3 a, Vector3 b, Vector3 c)</td></tr>
<tr class="memdesc:a4eaa3a1776729dc42edb3a3a73e59369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed area of a triangle in the XZ plane multiplied by 2.  <a href="class_pathfinding_1_1_vector_math.html#a4eaa3a1776729dc42edb3a3a73e59369">More...</a><br /></td></tr>
<tr class="separator:a4eaa3a1776729dc42edb3a3a73e59369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdcf8f89a1692a3eaaa0687d8044a99"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a2fdcf8f89a1692a3eaaa0687d8044a99">RightXZ</a> (Vector3 a, Vector3 b, Vector3 p)</td></tr>
<tr class="memdesc:a2fdcf8f89a1692a3eaaa0687d8044a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the right side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#a2fdcf8f89a1692a3eaaa0687d8044a99">More...</a><br /></td></tr>
<tr class="separator:a2fdcf8f89a1692a3eaaa0687d8044a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd201070482dfb1bac828bf991031b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a79fd201070482dfb1bac828bf991031b">RightXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> p)</td></tr>
<tr class="memdesc:a79fd201070482dfb1bac828bf991031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the right side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#a79fd201070482dfb1bac828bf991031b">More...</a><br /></td></tr>
<tr class="separator:a79fd201070482dfb1bac828bf991031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec53401504fa09b9adc0cf1923ee2e08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_pathfinding.html#a41b21610b2aea20573d8665e11bd3831">Side</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#aec53401504fa09b9adc0cf1923ee2e08">SideXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> p)</td></tr>
<tr class="memdesc:aec53401504fa09b9adc0cf1923ee2e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns which side of the line a - b that p lies on.  <a href="class_pathfinding_1_1_vector_math.html#aec53401504fa09b9adc0cf1923ee2e08">More...</a><br /></td></tr>
<tr class="separator:aec53401504fa09b9adc0cf1923ee2e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cc3f1355540868834aa6a901ca2f6c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a36cc3f1355540868834aa6a901ca2f6c">RightOrColinear</a> (Vector2 a, Vector2 b, Vector2 p)</td></tr>
<tr class="memdesc:a36cc3f1355540868834aa6a901ca2f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the right side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#a36cc3f1355540868834aa6a901ca2f6c">More...</a><br /></td></tr>
<tr class="separator:a36cc3f1355540868834aa6a901ca2f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116680f0f3f666c9302be5b1aec2b43b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a116680f0f3f666c9302be5b1aec2b43b">RightOrColinear</a> (<a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> a, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> b, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> p)</td></tr>
<tr class="memdesc:a116680f0f3f666c9302be5b1aec2b43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the right side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#a116680f0f3f666c9302be5b1aec2b43b">More...</a><br /></td></tr>
<tr class="separator:a116680f0f3f666c9302be5b1aec2b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c46308f4330b4e453a16d7839af87c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a2c46308f4330b4e453a16d7839af87c1">RightOrColinearXZ</a> (Vector3 a, Vector3 b, Vector3 p)</td></tr>
<tr class="memdesc:a2c46308f4330b4e453a16d7839af87c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the left side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#a2c46308f4330b4e453a16d7839af87c1">More...</a><br /></td></tr>
<tr class="separator:a2c46308f4330b4e453a16d7839af87c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3c877df1972553a81c96ed1289808d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#aed3c877df1972553a81c96ed1289808d">RightOrColinearXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> p)</td></tr>
<tr class="memdesc:aed3c877df1972553a81c96ed1289808d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if p lies on the left side of the line a - b.  <a href="class_pathfinding_1_1_vector_math.html#aed3c877df1972553a81c96ed1289808d">More...</a><br /></td></tr>
<tr class="separator:aed3c877df1972553a81c96ed1289808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad1e7a84b09829f9a834b850b6810b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ad6ad1e7a84b09829f9a834b850b6810b">IsClockwiseMarginXZ</a> (Vector3 a, Vector3 b, Vector3 c)</td></tr>
<tr class="memdesc:ad6ad1e7a84b09829f9a834b850b6810b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points a in a clockwise order.  <a href="class_pathfinding_1_1_vector_math.html#ad6ad1e7a84b09829f9a834b850b6810b">More...</a><br /></td></tr>
<tr class="separator:ad6ad1e7a84b09829f9a834b850b6810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f808d03fd0922629e4e981cfafaf31"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ab5f808d03fd0922629e4e981cfafaf31">IsClockwiseXZ</a> (Vector3 a, Vector3 b, Vector3 c)</td></tr>
<tr class="memdesc:ab5f808d03fd0922629e4e981cfafaf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points a in a clockwise order  <a href="class_pathfinding_1_1_vector_math.html#ab5f808d03fd0922629e4e981cfafaf31">More...</a><br /></td></tr>
<tr class="separator:ab5f808d03fd0922629e4e981cfafaf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357c13f5148034b69d980c3533d74b30"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a357c13f5148034b69d980c3533d74b30">IsClockwiseXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> c)</td></tr>
<tr class="memdesc:a357c13f5148034b69d980c3533d74b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points a in a clockwise order  <a href="class_pathfinding_1_1_vector_math.html#a357c13f5148034b69d980c3533d74b30">More...</a><br /></td></tr>
<tr class="separator:a357c13f5148034b69d980c3533d74b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe53aa0f513c36aeb13abddd4e863f67"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#abe53aa0f513c36aeb13abddd4e863f67">IsClockwiseOrColinearXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> c)</td></tr>
<tr class="memdesc:abe53aa0f513c36aeb13abddd4e863f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the points a in a clockwise order or if they are colinear  <a href="class_pathfinding_1_1_vector_math.html#abe53aa0f513c36aeb13abddd4e863f67">More...</a><br /></td></tr>
<tr class="separator:abe53aa0f513c36aeb13abddd4e863f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40216ae21069821264653e2433c4ab8d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a40216ae21069821264653e2433c4ab8d">IsClockwiseOrColinear</a> (<a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> a, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> b, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> c)</td></tr>
<tr class="memdesc:a40216ae21069821264653e2433c4ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the points a in a clockwise order or if they are colinear  <a href="class_pathfinding_1_1_vector_math.html#a40216ae21069821264653e2433c4ab8d">More...</a><br /></td></tr>
<tr class="separator:a40216ae21069821264653e2433c4ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dcf67843e3b17886080b6943ff10de"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a09dcf67843e3b17886080b6943ff10de">IsColinear</a> (Vector3 a, Vector3 b, Vector3 c)</td></tr>
<tr class="memdesc:a09dcf67843e3b17886080b6943ff10de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points are colinear (lie on a straight line)  <a href="class_pathfinding_1_1_vector_math.html#a09dcf67843e3b17886080b6943ff10de">More...</a><br /></td></tr>
<tr class="separator:a09dcf67843e3b17886080b6943ff10de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adead25d106f581ae27f7762f201d4723"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#adead25d106f581ae27f7762f201d4723">IsColinear</a> (Vector2 a, Vector2 b, Vector2 c)</td></tr>
<tr class="memdesc:adead25d106f581ae27f7762f201d4723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points are colinear (lie on a straight line)  <a href="class_pathfinding_1_1_vector_math.html#adead25d106f581ae27f7762f201d4723">More...</a><br /></td></tr>
<tr class="separator:adead25d106f581ae27f7762f201d4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad553c99d6a1b2f82bfc065b474daaa1f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ad553c99d6a1b2f82bfc065b474daaa1f">IsColinearXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> c)</td></tr>
<tr class="memdesc:ad553c99d6a1b2f82bfc065b474daaa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points are colinear (lie on a straight line)  <a href="class_pathfinding_1_1_vector_math.html#ad553c99d6a1b2f82bfc065b474daaa1f">More...</a><br /></td></tr>
<tr class="separator:ad553c99d6a1b2f82bfc065b474daaa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0c324387ab13d81df604c12fa34b4b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#aba0c324387ab13d81df604c12fa34b4b">IsColinearXZ</a> (Vector3 a, Vector3 b, Vector3 c)</td></tr>
<tr class="memdesc:aba0c324387ab13d81df604c12fa34b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points are colinear (lie on a straight line)  <a href="class_pathfinding_1_1_vector_math.html#aba0c324387ab13d81df604c12fa34b4b">More...</a><br /></td></tr>
<tr class="separator:aba0c324387ab13d81df604c12fa34b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fbf363dba1e44729c37fbf4795e85a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a11fbf363dba1e44729c37fbf4795e85a">IsColinearAlmostXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> a, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> b, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> c)</td></tr>
<tr class="memdesc:a11fbf363dba1e44729c37fbf4795e85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the points are colinear (lie on a straight line)  <a href="class_pathfinding_1_1_vector_math.html#a11fbf363dba1e44729c37fbf4795e85a">More...</a><br /></td></tr>
<tr class="separator:a11fbf363dba1e44729c37fbf4795e85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96922f85194e300d06a233464519cd9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#aa96922f85194e300d06a233464519cd9">SegmentsIntersect</a> (<a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> start1, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> end1, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> start2, <a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a> end2)</td></tr>
<tr class="memdesc:aa96922f85194e300d06a233464519cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the line segment start2 - end2 intersects the line segment start1 - end1.  <a href="class_pathfinding_1_1_vector_math.html#aa96922f85194e300d06a233464519cd9">More...</a><br /></td></tr>
<tr class="separator:aa96922f85194e300d06a233464519cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3fae46d19766bd8d2dc86cfb93513"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a54b3fae46d19766bd8d2dc86cfb93513">SegmentsIntersectXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start2, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end2)</td></tr>
<tr class="memdesc:a54b3fae46d19766bd8d2dc86cfb93513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the line segment start2 - end2 intersects the line segment start1 - end1.  <a href="class_pathfinding_1_1_vector_math.html#a54b3fae46d19766bd8d2dc86cfb93513">More...</a><br /></td></tr>
<tr class="separator:a54b3fae46d19766bd8d2dc86cfb93513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174eacc50b695efc96922310e9d8d7e5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a174eacc50b695efc96922310e9d8d7e5">SegmentsIntersectXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)</td></tr>
<tr class="memdesc:a174eacc50b695efc96922310e9d8d7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the two line segments intersects.  <a href="class_pathfinding_1_1_vector_math.html#a174eacc50b695efc96922310e9d8d7e5">More...</a><br /></td></tr>
<tr class="separator:a174eacc50b695efc96922310e9d8d7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbf1a776ee6d16b5879e488a9288f8d"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a5dbf1a776ee6d16b5879e488a9288f8d">LineDirIntersectionPointXZ</a> (Vector3 start1, Vector3 dir1, Vector3 start2, Vector3 dir2)</td></tr>
<tr class="memdesc:a5dbf1a776ee6d16b5879e488a9288f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection point between two infinite lines.  <a href="class_pathfinding_1_1_vector_math.html#a5dbf1a776ee6d16b5879e488a9288f8d">More...</a><br /></td></tr>
<tr class="separator:a5dbf1a776ee6d16b5879e488a9288f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1d5f22e7294b9d806e946e11edca5f"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a0d1d5f22e7294b9d806e946e11edca5f">LineDirIntersectionPointXZ</a> (Vector3 start1, Vector3 dir1, Vector3 start2, Vector3 dir2, out bool intersects)</td></tr>
<tr class="memdesc:a0d1d5f22e7294b9d806e946e11edca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection point between two infinite lines.  <a href="class_pathfinding_1_1_vector_math.html#a0d1d5f22e7294b9d806e946e11edca5f">More...</a><br /></td></tr>
<tr class="separator:a0d1d5f22e7294b9d806e946e11edca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd930c1b88346e412ea1a07f2188dd7d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#afd930c1b88346e412ea1a07f2188dd7d">RaySegmentIntersectXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start2, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end2)</td></tr>
<tr class="memdesc:afd930c1b88346e412ea1a07f2188dd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the ray (start1, end1) intersects the segment (start2, end2).  <a href="class_pathfinding_1_1_vector_math.html#afd930c1b88346e412ea1a07f2188dd7d">More...</a><br /></td></tr>
<tr class="separator:afd930c1b88346e412ea1a07f2188dd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69eeaf74ab3c1e8ab8087f478722eb03"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a69eeaf74ab3c1e8ab8087f478722eb03">LineIntersectionFactorXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start2, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end2, out float factor1, out float factor2)</td></tr>
<tr class="memdesc:a69eeaf74ab3c1e8ab8087f478722eb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection factors for line 1 and line 2.  <a href="class_pathfinding_1_1_vector_math.html#a69eeaf74ab3c1e8ab8087f478722eb03">More...</a><br /></td></tr>
<tr class="separator:a69eeaf74ab3c1e8ab8087f478722eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fd1e4c3655550910f79b5b66b3c84c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a61fd1e4c3655550910f79b5b66b3c84c">LineIntersectionFactorXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out float factor1, out float factor2)</td></tr>
<tr class="memdesc:a61fd1e4c3655550910f79b5b66b3c84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection factors for line 1 and line 2.  <a href="class_pathfinding_1_1_vector_math.html#a61fd1e4c3655550910f79b5b66b3c84c">More...</a><br /></td></tr>
<tr class="separator:a61fd1e4c3655550910f79b5b66b3c84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde50ec575dc13549c7607ad7d40f420"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#afde50ec575dc13549c7607ad7d40f420">LineRayIntersectionFactorXZ</a> (<a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end1, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> start2, <a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a> end2)</td></tr>
<tr class="memdesc:afde50ec575dc13549c7607ad7d40f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection factor for line 1 with ray 2.  <a href="class_pathfinding_1_1_vector_math.html#afde50ec575dc13549c7607ad7d40f420">More...</a><br /></td></tr>
<tr class="separator:afde50ec575dc13549c7607ad7d40f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c452b494bbc0e56a41eabb630b230f"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a08c452b494bbc0e56a41eabb630b230f">LineIntersectionFactorXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)</td></tr>
<tr class="memdesc:a08c452b494bbc0e56a41eabb630b230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection factor for line 1 with line 2.  <a href="class_pathfinding_1_1_vector_math.html#a08c452b494bbc0e56a41eabb630b230f">More...</a><br /></td></tr>
<tr class="separator:a08c452b494bbc0e56a41eabb630b230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e57721196dbe76005f89b463ebdba9"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#ad1e57721196dbe76005f89b463ebdba9">LineIntersectionPointXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)</td></tr>
<tr class="memdesc:ad1e57721196dbe76005f89b463ebdba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel  <a href="class_pathfinding_1_1_vector_math.html#ad1e57721196dbe76005f89b463ebdba9">More...</a><br /></td></tr>
<tr class="separator:ad1e57721196dbe76005f89b463ebdba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067aab46912a994a2ecd1d4a3ea13313"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a067aab46912a994a2ecd1d4a3ea13313">LineIntersectionPointXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out bool intersects)</td></tr>
<tr class="memdesc:a067aab46912a994a2ecd1d4a3ea13313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel  <a href="class_pathfinding_1_1_vector_math.html#a067aab46912a994a2ecd1d4a3ea13313">More...</a><br /></td></tr>
<tr class="separator:a067aab46912a994a2ecd1d4a3ea13313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aea15c2c7ad37b88839c31e067c0b5"><td class="memItemLeft" align="right" valign="top">static Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#af7aea15c2c7ad37b88839c31e067c0b5">LineIntersectionPoint</a> (Vector2 start1, Vector2 end1, Vector2 start2, Vector2 end2)</td></tr>
<tr class="memdesc:af7aea15c2c7ad37b88839c31e067c0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel  <a href="class_pathfinding_1_1_vector_math.html#af7aea15c2c7ad37b88839c31e067c0b5">More...</a><br /></td></tr>
<tr class="separator:af7aea15c2c7ad37b88839c31e067c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b9d8fcd9ddf2d8c9403e1cc54acf8d"><td class="memItemLeft" align="right" valign="top">static Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a62b9d8fcd9ddf2d8c9403e1cc54acf8d">LineIntersectionPoint</a> (Vector2 start1, Vector2 end1, Vector2 start2, Vector2 end2, out bool intersects)</td></tr>
<tr class="memdesc:a62b9d8fcd9ddf2d8c9403e1cc54acf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel  <a href="class_pathfinding_1_1_vector_math.html#a62b9d8fcd9ddf2d8c9403e1cc54acf8d">More...</a><br /></td></tr>
<tr class="separator:a62b9d8fcd9ddf2d8c9403e1cc54acf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d8c8012ff4f60243fc5fdd9669163"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a454d8c8012ff4f60243fc5fdd9669163">SegmentIntersectionPointXZ</a> (Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out bool intersects)</td></tr>
<tr class="memdesc:a454d8c8012ff4f60243fc5fdd9669163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection point between the two line segments in XZ space.  <a href="class_pathfinding_1_1_vector_math.html#a454d8c8012ff4f60243fc5fdd9669163">More...</a><br /></td></tr>
<tr class="separator:a454d8c8012ff4f60243fc5fdd9669163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cd1d8e94d0e1a11f23eeede19e6999"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a96cd1d8e94d0e1a11f23eeede19e6999">SegmentIntersectsBounds</a> (Bounds bounds, Vector3 a, Vector3 b)</td></tr>
<tr class="memdesc:a96cd1d8e94d0e1a11f23eeede19e6999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the line segment intersect the bounding box.  <a href="class_pathfinding_1_1_vector_math.html#a96cd1d8e94d0e1a11f23eeede19e6999">More...</a><br /></td></tr>
<tr class="separator:a96cd1d8e94d0e1a11f23eeede19e6999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7312a3ddf0fd15b6195a1b170647320d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a7312a3ddf0fd15b6195a1b170647320d">LineCircleIntersectionFactor</a> (Vector3 circleCenter, Vector3 linePoint1, Vector3 linePoint2, float radius)</td></tr>
<tr class="memdesc:a7312a3ddf0fd15b6195a1b170647320d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of a line and a circle.  <a href="class_pathfinding_1_1_vector_math.html#a7312a3ddf0fd15b6195a1b170647320d">More...</a><br /></td></tr>
<tr class="separator:a7312a3ddf0fd15b6195a1b170647320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ad20d9b2623ad2988bdc9cfc7c26b3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a48ad20d9b2623ad2988bdc9cfc7c26b3">ReversesFaceOrientations</a> (Matrix4x4 matrix)</td></tr>
<tr class="memdesc:a48ad20d9b2623ad2988bdc9cfc7c26b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the matrix will reverse orientations of faces.  <a href="class_pathfinding_1_1_vector_math.html#a48ad20d9b2623ad2988bdc9cfc7c26b3">More...</a><br /></td></tr>
<tr class="separator:a48ad20d9b2623ad2988bdc9cfc7c26b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb34a73db142afb96e900e724d49a86"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a7fb34a73db142afb96e900e724d49a86">ReversesFaceOrientationsXZ</a> (Matrix4x4 matrix)</td></tr>
<tr class="memdesc:a7fb34a73db142afb96e900e724d49a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the matrix will reverse orientations of faces in the XZ plane.  <a href="class_pathfinding_1_1_vector_math.html#a7fb34a73db142afb96e900e724d49a86">More...</a><br /></td></tr>
<tr class="separator:a7fb34a73db142afb96e900e724d49a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb496aa5182e2cc9b50bddd9fa6981c"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#afdb496aa5182e2cc9b50bddd9fa6981c">Normalize</a> (Vector3 v, out float magnitude)</td></tr>
<tr class="memdesc:afdb496aa5182e2cc9b50bddd9fa6981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize vector and also return the magnitude.  <a href="class_pathfinding_1_1_vector_math.html#afdb496aa5182e2cc9b50bddd9fa6981c">More...</a><br /></td></tr>
<tr class="separator:afdb496aa5182e2cc9b50bddd9fa6981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3293d954b33c529e41293babd01818"><td class="memItemLeft" align="right" valign="top">static Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a2a3293d954b33c529e41293babd01818">Normalize</a> (Vector2 v, out float magnitude)</td></tr>
<tr class="memdesc:a2a3293d954b33c529e41293babd01818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize vector and also return the magnitude.  <a href="class_pathfinding_1_1_vector_math.html#a2a3293d954b33c529e41293babd01818">More...</a><br /></td></tr>
<tr class="separator:a2a3293d954b33c529e41293babd01818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e658fcdded2a338d8766507c05b100"><td class="memItemLeft" align="right" valign="top">static Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a89e658fcdded2a338d8766507c05b100">ClampMagnitudeXZ</a> (Vector3 v, float maxMagnitude)</td></tr>
<tr class="separator:a89e658fcdded2a338d8766507c05b100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e08d38158be6c4c6764c83606ecbb3"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_vector_math.html#a12e08d38158be6c4c6764c83606ecbb3">MagnitudeXZ</a> (Vector3 v)</td></tr>
<tr class="separator:a12e08d38158be6c4c6764c83606ecbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various vector math utility functions. </p>
<p>Version: A lot of functions in the <a class="el" href="class_pathfinding_1_1_polygon.html" title="Utility functions for working with polygons, lines, and other vector math.">Polygon</a> class have been moved to this class the names have changed slightly and everything now consistently assumes a left handed coordinate system now instead of sometimes using a left handed one and sometimes using a right handed one. This is why the 'Left' methods in the <a class="el" href="class_pathfinding_1_1_polygon.html" title="Utility functions for working with polygons, lines, and other vector math.">Polygon</a> class redirect to methods named 'Right'. The functionality is exactly the same.</p>
<p>Note the difference between segments and lines. Lines are infinitely long but segments have only a finite length.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a89e658fcdded2a338d8766507c05b100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e658fcdded2a338d8766507c05b100">&#9670;&nbsp;</a></span>ClampMagnitudeXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.ClampMagnitudeXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a116acf72b5591b3f4c82532a8d3cf7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116acf72b5591b3f4c82532a8d3cf7d5">&#9670;&nbsp;</a></span>ClosestPointOnLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.ClosestPointOnLine </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the closest point on the line. </p>
<p>The line is treated as infinite. See: ClosestPointOnSegment See: ClosestPointOnLineFactor</p>

</div>
</div>
<a id="ab79067e13005b86e7daea6923d769889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79067e13005b86e7daea6923d769889">&#9670;&nbsp;</a></span>ClosestPointOnLineFactor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.ClosestPointOnLineFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor of the nearest point on the segment. </p>
<p>Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line. The closest point can be calculated using (end-start)*factor + start;</p>

</div>
</div>
<a id="a36a7ff9cc27bda631b034bd7ea3f5362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a7ff9cc27bda631b034bd7ea3f5362">&#9670;&nbsp;</a></span>ClosestPointOnLineFactor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.ClosestPointOnLineFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor along the line which is closest to the point. </p>
<p>Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line. The closest point can be calculated using (end-start)*factor + start</p>

</div>
</div>
<a id="a8cb33e82b3464ee7432eb023a401d2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb33e82b3464ee7432eb023a401d2bd">&#9670;&nbsp;</a></span>ClosestPointOnLineFactor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.ClosestPointOnLineFactor </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor along the line which is closest to the point. </p>
<p>Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line. The closest point can be calculated using (end-start)*factor + start.</p>
<p>See: ClosestPointOnLine See: ClosestPointOnSegment</p>

</div>
</div>
<a id="a36542f38432fe94ee67f4ffd206a77f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36542f38432fe94ee67f4ffd206a77f1">&#9670;&nbsp;</a></span>ClosestPointOnSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.ClosestPointOnSegment </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the closest point on the segment. </p>
<p>The segment is NOT treated as infinite. See: ClosestPointOnLine See: ClosestPointOnSegmentXZ</p>

</div>
</div>
<a id="a40bcf48907fc3ab7e699f8da4bdb5ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bcf48907fc3ab7e699f8da4bdb5ff8">&#9670;&nbsp;</a></span>ClosestPointOnSegmentXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.ClosestPointOnSegmentXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>lineEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the closest point on the segment in the XZ plane. </p>
<p>The y coordinate of the result will be the same as the y coordinate of the point parameter.</p>
<p>The segment is NOT treated as infinite. See: ClosestPointOnSegment See: ClosestPointOnLine</p>

</div>
</div>
<a id="a03876b8c0a0d21fa8eb9e280e647f3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03876b8c0a0d21fa8eb9e280e647f3d1">&#9670;&nbsp;</a></span>ComplexMultiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector2 Pathfinding.VectorMath.ComplexMultiply </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex number multiplication. </p>
<p>Returns: a * b</p>
<p>Used to rotate vectors in an efficient way.</p>
<p>See: <a href="https://en.wikipedia.org/wiki/Complex_number">https://en.wikipedia.org/wiki/Complex_number</a>Multiplication_and_division</p>

</div>
</div>
<a id="a54385ca63c8579407785f91976cd9be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54385ca63c8579407785f91976cd9be2">&#9670;&nbsp;</a></span>ComplexMultiplyConjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector2 Pathfinding.VectorMath.ComplexMultiplyConjugate </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex number multiplication. </p>
<p>Returns: a * conjugate(b)</p>
<p>Used to rotate vectors in an efficient way.</p>
<p>See: <a href="https://en.wikipedia.org/wiki/Complex_number">https://en.wikipedia.org/wiki/Complex_number</a>Multiplication_and_division See: <a href="https://en.wikipedia.org/wiki/Complex_conjugate">https://en.wikipedia.org/wiki/Complex_conjugate</a></p>

</div>
</div>
<a id="ad6ad1e7a84b09829f9a834b850b6810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ad1e7a84b09829f9a834b850b6810b">&#9670;&nbsp;</a></span>IsClockwiseMarginXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsClockwiseMarginXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points a in a clockwise order. </p>
<p>Will return true even if the points are colinear or very slightly counter-clockwise (if the signed area of the triangle formed by the points has an area less than or equals to float.Epsilon)</p>

</div>
</div>
<a id="a40216ae21069821264653e2433c4ab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40216ae21069821264653e2433c4ab8d">&#9670;&nbsp;</a></span>IsClockwiseOrColinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsClockwiseOrColinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the points a in a clockwise order or if they are colinear </p>

</div>
</div>
<a id="abe53aa0f513c36aeb13abddd4e863f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe53aa0f513c36aeb13abddd4e863f67">&#9670;&nbsp;</a></span>IsClockwiseOrColinearXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsClockwiseOrColinearXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the points a in a clockwise order or if they are colinear </p>

</div>
</div>
<a id="a357c13f5148034b69d980c3533d74b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357c13f5148034b69d980c3533d74b30">&#9670;&nbsp;</a></span>IsClockwiseXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsClockwiseXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points a in a clockwise order </p>

</div>
</div>
<a id="ab5f808d03fd0922629e4e981cfafaf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f808d03fd0922629e4e981cfafaf31">&#9670;&nbsp;</a></span>IsClockwiseXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsClockwiseXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points a in a clockwise order </p>

</div>
</div>
<a id="adead25d106f581ae27f7762f201d4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adead25d106f581ae27f7762f201d4723">&#9670;&nbsp;</a></span>IsColinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsColinear </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points are colinear (lie on a straight line) </p>

</div>
</div>
<a id="a09dcf67843e3b17886080b6943ff10de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dcf67843e3b17886080b6943ff10de">&#9670;&nbsp;</a></span>IsColinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsColinear </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points are colinear (lie on a straight line) </p>

</div>
</div>
<a id="a11fbf363dba1e44729c37fbf4795e85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fbf363dba1e44729c37fbf4795e85a">&#9670;&nbsp;</a></span>IsColinearAlmostXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsColinearAlmostXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points are colinear (lie on a straight line) </p>

</div>
</div>
<a id="ad553c99d6a1b2f82bfc065b474daaa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad553c99d6a1b2f82bfc065b474daaa1f">&#9670;&nbsp;</a></span>IsColinearXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsColinearXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points are colinear (lie on a straight line) </p>

</div>
</div>
<a id="aba0c324387ab13d81df604c12fa34b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0c324387ab13d81df604c12fa34b4b">&#9670;&nbsp;</a></span>IsColinearXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.IsColinearXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the points are colinear (lie on a straight line) </p>

</div>
</div>
<a id="a7312a3ddf0fd15b6195a1b170647320d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7312a3ddf0fd15b6195a1b170647320d">&#9670;&nbsp;</a></span>LineCircleIntersectionFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.LineCircleIntersectionFactor </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>circleCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>linePoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>linePoint2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection of a line and a circle. </p>
<p>Returns the greatest t such that segmentStart+t*(segmentEnd-segmentStart) lies on the circle.</p>
<p>In case the line does not intersect with the circle, the closest point on the line to the circle will be returned.</p>
<p>Note: Works for line and sphere in 3D space as well.</p>
<p>See: <a href="http://mathworld.wolfram.com/Circle-LineIntersection.html">http://mathworld.wolfram.com/Circle-LineIntersection.html</a> See: <a href="https://en.wikipedia.org/wiki/Intersection_(Euclidean_geometry)">https://en.wikipedia.org/wiki/Intersection_(Euclidean_geometry)</a>A_line_and_a_circle</p>

</div>
</div>
<a id="a5dbf1a776ee6d16b5879e488a9288f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbf1a776ee6d16b5879e488a9288f8d">&#9670;&nbsp;</a></span>LineDirIntersectionPointXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.LineDirIntersectionPointXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>dir1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>dir2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection point between two infinite lines. </p>
<p>Note that start points and directions are taken as parameters instead of start and end points. Lines are treated as infinite. If the lines are parallel 'start1' will be returned. Intersections are calculated on the XZ plane.</p>
<p>See: LineIntersectionPointXZ</p>

</div>
</div>
<a id="a0d1d5f22e7294b9d806e946e11edca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1d5f22e7294b9d806e946e11edca5f">&#9670;&nbsp;</a></span>LineDirIntersectionPointXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.LineDirIntersectionPointXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>dir1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>dir2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>intersects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection point between two infinite lines. </p>
<p>Note that start points and directions are taken as parameters instead of start and end points. Lines are treated as infinite. If the lines are parallel 'start1' will be returned. Intersections are calculated on the XZ plane.</p>
<p>See: LineIntersectionPointXZ</p>

</div>
</div>
<a id="a69eeaf74ab3c1e8ab8087f478722eb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69eeaf74ab3c1e8ab8087f478722eb03">&#9670;&nbsp;</a></span>LineIntersectionFactorXZ() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.LineIntersectionFactorXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>factor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>factor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection factors for line 1 and line 2. </p>
<p>The intersection factors is a distance along the line start - end where the other line intersects it.<br  />
<code> intersectionPoint = start1 + factor1 * (end1-start1) </code> <code> intersectionPoint2 = start2 + factor2 * (end2-start2) </code> Lines are treated as infinite.<br  />
false is returned if the lines are parallel and true if they are not. Only the XZ coordinates are used.</p>

</div>
</div>
<a id="a08c452b494bbc0e56a41eabb630b230f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c452b494bbc0e56a41eabb630b230f">&#9670;&nbsp;</a></span>LineIntersectionFactorXZ() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.LineIntersectionFactorXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection factor for line 1 with line 2. </p>
<p>The intersection factor is a distance along the line start1 - end1 where the line start2 - end2 intersects it.<br  />
<code> intersectionPoint = start1 + intersectionFactor * (end1-start1) </code>. Lines are treated as infinite.<br  />
-1 is returned if the lines are parallel (note that this is a valid return value if they are not parallel too)</p>

</div>
</div>
<a id="a61fd1e4c3655550910f79b5b66b3c84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd1e4c3655550910f79b5b66b3c84c">&#9670;&nbsp;</a></span>LineIntersectionFactorXZ() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.LineIntersectionFactorXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>factor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>factor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection factors for line 1 and line 2. </p>
<p>The intersection factors is a distance along the line start - end where the other line intersects it.<br  />
<code> intersectionPoint = start1 + factor1 * (end1-start1) </code> <code> intersectionPoint2 = start2 + factor2 * (end2-start2) </code> Lines are treated as infinite.<br  />
false is returned if the lines are parallel and true if they are not. Only the XZ coordinates are used.</p>

</div>
</div>
<a id="af7aea15c2c7ad37b88839c31e067c0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7aea15c2c7ad37b88839c31e067c0b5">&#9670;&nbsp;</a></span>LineIntersectionPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector2 Pathfinding.VectorMath.LineIntersectionPoint </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel </p>

</div>
</div>
<a id="a62b9d8fcd9ddf2d8c9403e1cc54acf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b9d8fcd9ddf2d8c9403e1cc54acf8d">&#9670;&nbsp;</a></span>LineIntersectionPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector2 Pathfinding.VectorMath.LineIntersectionPoint </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>intersects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel </p>

</div>
</div>
<a id="ad1e57721196dbe76005f89b463ebdba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e57721196dbe76005f89b463ebdba9">&#9670;&nbsp;</a></span>LineIntersectionPointXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.LineIntersectionPointXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel </p>

</div>
</div>
<a id="a067aab46912a994a2ecd1d4a3ea13313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067aab46912a994a2ecd1d4a3ea13313">&#9670;&nbsp;</a></span>LineIntersectionPointXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.LineIntersectionPointXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>intersects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection point between the two lines. Lines are treated as infinite. start1 is returned if the lines are parallel </p>

</div>
</div>
<a id="afde50ec575dc13549c7607ad7d40f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde50ec575dc13549c7607ad7d40f420">&#9670;&nbsp;</a></span>LineRayIntersectionFactorXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.LineRayIntersectionFactorXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection factor for line 1 with ray 2. </p>
<p>The intersection factors is a factor distance along the line start - end where the other line intersects it.<br  />
<code> intersectionPoint = start1 + factor * (end1-start1) </code> Lines are treated as infinite.<br  />
 The second "line" is treated as a ray, meaning only matches on start2 or forwards towards end2 (and beyond) will be returned If the point lies on the wrong side of the ray start, Nan will be returned.</p>
<p>NaN is returned if the lines are parallel.</p>

</div>
</div>
<a id="a12e08d38158be6c4c6764c83606ecbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e08d38158be6c4c6764c83606ecbb3">&#9670;&nbsp;</a></span>MagnitudeXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.MagnitudeXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3293d954b33c529e41293babd01818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3293d954b33c529e41293babd01818">&#9670;&nbsp;</a></span>Normalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector2 Pathfinding.VectorMath.Normalize </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize vector and also return the magnitude. </p>
<p>This is more efficient than calculating the magnitude and normalizing separately</p>

</div>
</div>
<a id="afdb496aa5182e2cc9b50bddd9fa6981c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb496aa5182e2cc9b50bddd9fa6981c">&#9670;&nbsp;</a></span>Normalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.Normalize </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out float&#160;</td>
          <td class="paramname"><em>magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize vector and also return the magnitude. </p>
<p>This is more efficient than calculating the magnitude and normalizing separately</p>

</div>
</div>
<a id="afd930c1b88346e412ea1a07f2188dd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd930c1b88346e412ea1a07f2188dd7d">&#9670;&nbsp;</a></span>RaySegmentIntersectXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RaySegmentIntersectXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the ray (start1, end1) intersects the segment (start2, end2). </p>
<p>false is returned if the lines are parallel. Only the XZ coordinates are used. TODO: Double check that this actually works</p>

</div>
</div>
<a id="a48ad20d9b2623ad2988bdc9cfc7c26b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ad20d9b2623ad2988bdc9cfc7c26b3">&#9670;&nbsp;</a></span>ReversesFaceOrientations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.ReversesFaceOrientations </td>
          <td>(</td>
          <td class="paramtype">Matrix4x4&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the matrix will reverse orientations of faces. </p>
<p>Scaling by a negative value along an odd number of axes will reverse the orientation of e.g faces on a mesh. This must be counter adjusted by for example the recast rasterization system to be able to handle meshes with negative scales properly.</p>
<p>We can find out if they are flipped by finding out how the signed volume of a unit cube is transformed when applying the matrix</p>
<p>If the (signed) volume turns out to be negative that also means that the orientation of it has been reversed.</p>
<p>See: <a href="https://en.wikipedia.org/wiki/Normal_(geometry)">https://en.wikipedia.org/wiki/Normal_(geometry)</a> See: <a href="https://en.wikipedia.org/wiki/Parallelepiped">https://en.wikipedia.org/wiki/Parallelepiped</a></p>

</div>
</div>
<a id="a7fb34a73db142afb96e900e724d49a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb34a73db142afb96e900e724d49a86">&#9670;&nbsp;</a></span>ReversesFaceOrientationsXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.ReversesFaceOrientationsXZ </td>
          <td>(</td>
          <td class="paramtype">Matrix4x4&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the matrix will reverse orientations of faces in the XZ plane. </p>
<p>Almost the same as ReversesFaceOrientations, but this method assumes that scaling a face with a negative scale along the Y axis does not reverse the orientation of the face.</p>
<p>This is used for navmesh cuts.</p>
<p>Scaling by a negative value along one axis or rotating it so that it is upside down will reverse the orientation of the cut, so we need to be reverse it again as a countermeasure. However if it is flipped along two axes it does not need to be reversed. We can handle all these cases by finding out how a unit square formed by our forward axis and our rightward axis is transformed in XZ space when applying the local to world matrix. If the (signed) area of the unit square turns out to be negative that also means that the orientation of it has been reversed. The signed area is calculated using a cross product of the vectors.</p>

</div>
</div>
<a id="a116680f0f3f666c9302be5b1aec2b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116680f0f3f666c9302be5b1aec2b43b">&#9670;&nbsp;</a></span>RightOrColinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightOrColinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the right side of the line a - b. </p>
<p>Also returns true if the points are colinear.</p>

</div>
</div>
<a id="a36cc3f1355540868834aa6a901ca2f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cc3f1355540868834aa6a901ca2f6c">&#9670;&nbsp;</a></span>RightOrColinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightOrColinear </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the right side of the line a - b. </p>
<p>Also returns true if the points are colinear.</p>

</div>
</div>
<a id="aed3c877df1972553a81c96ed1289808d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3c877df1972553a81c96ed1289808d">&#9670;&nbsp;</a></span>RightOrColinearXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightOrColinearXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the left side of the line a - b. </p>
<p>Uses XZ space. Also returns true if the points are colinear.</p>

</div>
</div>
<a id="a2c46308f4330b4e453a16d7839af87c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c46308f4330b4e453a16d7839af87c1">&#9670;&nbsp;</a></span>RightOrColinearXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightOrColinearXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the left side of the line a - b. </p>
<p>Uses XZ space. Also returns true if the points are colinear.</p>

</div>
</div>
<a id="a79fd201070482dfb1bac828bf991031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fd201070482dfb1bac828bf991031b">&#9670;&nbsp;</a></span>RightXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the right side of the line a - b. </p>
<p>Uses XZ space. Does not return true if the points are colinear.</p>

</div>
</div>
<a id="a2fdcf8f89a1692a3eaaa0687d8044a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdcf8f89a1692a3eaaa0687d8044a99">&#9670;&nbsp;</a></span>RightXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.RightXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if p lies on the right side of the line a - b. </p>
<p>Uses XZ space. Does not return true if the points are colinear.</p>

</div>
</div>
<a id="a454d8c8012ff4f60243fc5fdd9669163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d8c8012ff4f60243fc5fdd9669163">&#9670;&nbsp;</a></span>SegmentIntersectionPointXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Vector3 Pathfinding.VectorMath.SegmentIntersectionPointXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>intersects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection point between the two line segments in XZ space. </p>
<p>Lines are NOT treated as infinite. start1 is returned if the line segments do not intersect The point will be returned along the line [start1, end1] (this matters only for the y coordinate).</p>

</div>
</div>
<a id="a96cd1d8e94d0e1a11f23eeede19e6999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cd1d8e94d0e1a11f23eeede19e6999">&#9670;&nbsp;</a></span>SegmentIntersectsBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.SegmentIntersectsBounds </td>
          <td>(</td>
          <td class="paramtype">Bounds&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the line segment intersect the bounding box. </p>
<p>The line is NOT treated as infinite. </p><dl class="section author"><dt>Author</dt><dd>Slightly modified code from <a href="http://www.3dkingdoms.com/weekly/weekly.php?a=21">http://www.3dkingdoms.com/weekly/weekly.php?a=21</a></dd></dl>

</div>
</div>
<a id="aa96922f85194e300d06a233464519cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96922f85194e300d06a233464519cd9">&#9670;&nbsp;</a></span>SegmentsIntersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.SegmentsIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int2.html">Int2</a>&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the line segment start2 - end2 intersects the line segment start1 - end1. </p>
<p>If only the endpoints coincide, the result is undefined (may be true or false).</p>

</div>
</div>
<a id="a54b3fae46d19766bd8d2dc86cfb93513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b3fae46d19766bd8d2dc86cfb93513">&#9670;&nbsp;</a></span>SegmentsIntersectXZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.SegmentsIntersectXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the line segment start2 - end2 intersects the line segment start1 - end1. </p>
<p>If only the endpoints coincide, the result is undefined (may be true or false).</p>
<p>Note: XZ space</p>

</div>
</div>
<a id="a174eacc50b695efc96922310e9d8d7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174eacc50b695efc96922310e9d8d7e5">&#9670;&nbsp;</a></span>SegmentsIntersectXZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.VectorMath.SegmentsIntersectXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the two line segments intersects. </p>
<p>The lines are NOT treated as infinite (just for clarification) See: IntersectionPoint</p>

</div>
</div>
<a id="aec53401504fa09b9adc0cf1923ee2e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec53401504fa09b9adc0cf1923ee2e08">&#9670;&nbsp;</a></span>SideXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_pathfinding.html#a41b21610b2aea20573d8665e11bd3831">Side</a> Pathfinding.VectorMath.SideXZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns which side of the line a - b that p lies on. </p>
<p>Uses XZ space.</p>

</div>
</div>
<a id="ae541625b686e37660142a01dcde15238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541625b686e37660142a01dcde15238">&#9670;&nbsp;</a></span>SignedTriangleAreaTimes2XZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long Pathfinding.VectorMath.SignedTriangleAreaTimes2XZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signed area of a triangle in the XZ plane multiplied by 2. </p>
<p>This will be negative for clockwise triangles and positive for counter-clockwise ones</p>

</div>
</div>
<a id="a4eaa3a1776729dc42edb3a3a73e59369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaa3a1776729dc42edb3a3a73e59369">&#9670;&nbsp;</a></span>SignedTriangleAreaTimes2XZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SignedTriangleAreaTimes2XZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signed area of a triangle in the XZ plane multiplied by 2. </p>
<p>This will be negative for clockwise triangles and positive for counter-clockwise ones.</p>

</div>
</div>
<a id="a8bfeac78a0cd2131138f9c2e620983d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfeac78a0cd2131138f9c2e620983d6">&#9670;&nbsp;</a></span>SqrDistancePointSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SqrDistancePointSegment </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared distance between p and the segment a-b. </p>
<p>The line is not considered infinite.</p>

</div>
</div>
<a id="a25ad12e9697b1caf8805bfb8b9994e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ad12e9697b1caf8805bfb8b9994e20">&#9670;&nbsp;</a></span>SqrDistancePointSegmentApproximate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SqrDistancePointSegmentApproximate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the approximate shortest squared distance between x,z and the segment p-q. </p>
<p>The segment is not considered infinite. This function is not entirely exact, but it is about twice as fast as DistancePointSegment2. TODO: Is this actually approximate? It looks exact.</p>

</div>
</div>
<a id="a69d3201f5992cdfd3a398ef7d8cf8465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d3201f5992cdfd3a398ef7d8cf8465">&#9670;&nbsp;</a></span>SqrDistancePointSegmentApproximate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SqrDistancePointSegmentApproximate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pathfinding_1_1_int3.html">Int3</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the approximate shortest squared distance between x,z and the segment p-q. </p>
<p>The segment is not considered infinite. This function is not entirely exact, but it is about twice as fast as DistancePointSegment2. TODO: Is this actually approximate? It looks exact.</p>

</div>
</div>
<a id="ab28c685f0070362cf3ed9f41260c689c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28c685f0070362cf3ed9f41260c689c">&#9670;&nbsp;</a></span>SqrDistanceSegmentSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SqrDistanceSegmentSegment </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D minimum distance between 2 segments. </p>
<p>Input: two 3D line segments S1 and S2 Returns: the shortest squared distance between S1 and S2</p>

</div>
</div>
<a id="a73b2f9d00ffb6f169b50c61c6e08693c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b2f9d00ffb6f169b50c61c6e08693c">&#9670;&nbsp;</a></span>SqrDistanceXZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Pathfinding.VectorMath.SqrDistanceXZ </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squared distance between two points in the XZ plane </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Shooter-Game/Shooter-Game/Assets/AstarPathfindingProject/Core/<a class="el" href="_astar_math_8cs.html">AstarMath.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_pathfinding.html">Pathfinding</a></li><li class="navelem"><a class="el" href="class_pathfinding_1_1_vector_math.html">VectorMath</a></li>
    <li class="footer">Generated on Tue May 26 2020 10:45:33 for Shooter-Game by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
